#!/bin/bash
# post_bootstrap.sh - Patroni post-bootstrap script
#
# Runs ONCE after PostgreSQL initialization on the primary node.
# Patroni 4.0+ removed bootstrap.users, so users must be created here.
#
# IMPORTANT: Patroni runs this as a subprocess WITHOUT environment variables.
# We MUST read credentials from /tmp/patroni.yml (generated by patroni-runner.sh)
#
# Patroni passes:
#   $1 = connection string URL (e.g., postgres://user@localhost:5432/postgres)
#   PGPASSFILE = path to pgpass file for authentication

set -e

echo "Post-bootstrap: starting..."

# Connection URL passed by Patroni (includes superuser credentials)
CONN_URL="${1:-}"

echo "DEBUG: Connection URL provided: ${CONN_URL:+yes}"
echo "DEBUG: PGPASSFILE=${PGPASSFILE:-not set}"

# Read credentials from the Patroni config file
# This is generated by patroni-runner.sh before starting Patroni
PATRONI_CONFIG="/tmp/patroni.yml"

if [ ! -f "$PATRONI_CONFIG" ]; then
    echo "ERROR: Patroni config not found at $PATRONI_CONFIG"
    exit 1
fi

# Extract credentials from YAML (simple grep since yq may not be available)
# The YAML structure is:
#   authentication:
#     replication:
#       username: replicator
#       password: xxxxx
#     superuser:
#       username: postgres
#       password: xxxxx
#   app_user:
#     username: postgres
#     password: xxxxx

# Extract value from "key: value" and strip quotes
strip_yaml() {
    sed 's/.*: *//' | sed 's/^["'"'"']//' | sed 's/["'"'"']$//'
}

REPL_USER=$(grep -A2 'replication:' "$PATRONI_CONFIG" | grep 'username:' | head -1 | strip_yaml)
REPL_PASS=$(grep -A2 'replication:' "$PATRONI_CONFIG" | grep 'password:' | head -1 | strip_yaml)
SUPERUSER=$(grep -A2 'superuser:' "$PATRONI_CONFIG" | grep 'username:' | head -1 | strip_yaml)
SUPERUSER_PASS=$(grep -A2 'superuser:' "$PATRONI_CONFIG" | grep 'password:' | head -1 | strip_yaml)
APP_USER=$(grep -A3 'app_user:' "$PATRONI_CONFIG" | grep 'username:' | head -1 | strip_yaml)
APP_PASS=$(grep -A3 'app_user:' "$PATRONI_CONFIG" | grep 'password:' | head -1 | strip_yaml)
APP_DB=$(grep -A3 'app_user:' "$PATRONI_CONFIG" | grep 'database:' | head -1 | strip_yaml)

echo "DEBUG: REPL_USER=${REPL_USER}"
echo "DEBUG: REPL_PASS length=${#REPL_PASS}"
echo "DEBUG: REPL_PASS first4=${REPL_PASS:0:4} last4=${REPL_PASS: -4}"
echo "DEBUG: SUPERUSER=${SUPERUSER}"
echo "DEBUG: APP_DB=${APP_DB}"
echo "DEBUG: Raw password line from YAML:"
grep -A2 'replication:' "$PATRONI_CONFIG" | grep 'password:' | head -1 | cat -A

if [ -z "$REPL_USER" ] || [ -z "$REPL_PASS" ]; then
    echo "ERROR: Could not extract replication credentials from Patroni config"
    echo "Config file contents (passwords redacted):"
    sed 's/password:.*/password: [REDACTED]/' "$PATRONI_CONFIG"
    exit 1
fi

if [ -z "$SUPERUSER" ]; then
    echo "ERROR: Could not extract superuser from Patroni config"
    exit 1
fi

# Patroni passes --username to initdb, so the superuser is whatever is configured
echo "Post-bootstrap: setting up users (connecting as $SUPERUSER)..."

# Use env -i to run psql with a completely clean environment
# This ensures no PG* variables can interfere with the -h flag

# Use format() for ALL password operations to ensure proper escaping
# This prevents SQL injection and handles any special characters correctly
env -i PATH="$PATH" psql -v ON_ERROR_STOP=1 -h /var/run/postgresql -U "$SUPERUSER" -d postgres <<EOSQL
-- Ensure SCRAM-SHA-256 is used (DCS config may not be applied yet)
SET password_encryption = 'scram-sha-256';

-- Set password for the superuser (already exists from initdb)
-- Using format() for proper escaping
DO \$\$
BEGIN
    EXECUTE format('ALTER ROLE %I WITH PASSWORD %L', '${SUPERUSER}', '${SUPERUSER_PASS}');
    RAISE NOTICE 'Set password for superuser: ${SUPERUSER}';
END
\$\$;

-- Create or update replication user
DO \$\$
DECLARE
    pass TEXT := '${REPL_PASS}';
BEGIN
    RAISE NOTICE 'DEBUG FULL PASSWORD: [%]', pass;
    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = '${REPL_USER}') THEN
        EXECUTE format('CREATE ROLE %I WITH REPLICATION LOGIN PASSWORD %L', '${REPL_USER}', pass);
        RAISE NOTICE 'Created replication user: ${REPL_USER}';
    ELSE
        EXECUTE format('ALTER ROLE %I WITH REPLICATION LOGIN PASSWORD %L', '${REPL_USER}', pass);
        RAISE NOTICE 'Updated replication user: ${REPL_USER}';
    END IF;
END
\$\$;

-- Create or update app user (POSTGRES_USER) if different from superuser
DO \$\$
BEGIN
    -- Skip if app_user is same as superuser (already handled above)
    IF '${APP_USER}' = '${SUPERUSER}' THEN
        RAISE NOTICE 'App user same as superuser, skipping';
    ELSIF '${APP_USER}' = '' OR '${APP_PASS}' = '' THEN
        RAISE NOTICE 'App user not configured, skipping';
    ELSIF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = '${APP_USER}') THEN
        EXECUTE format('CREATE ROLE %I WITH LOGIN PASSWORD %L', '${APP_USER}', '${APP_PASS}');
        RAISE NOTICE 'Created app user: ${APP_USER}';
    ELSE
        EXECUTE format('ALTER ROLE %I WITH PASSWORD %L', '${APP_USER}', '${APP_PASS}');
        RAISE NOTICE 'Updated app user: ${APP_USER}';
    END IF;
END
\$\$;

-- Create app database if configured and doesn't exist
DO \$\$
BEGIN
    IF '${APP_DB}' = '' OR '${APP_DB}' = 'postgres' THEN
        RAISE NOTICE 'App database not configured or is postgres, skipping';
    ELSIF NOT EXISTS (SELECT FROM pg_database WHERE datname = '${APP_DB}') THEN
        EXECUTE format('CREATE DATABASE %I', '${APP_DB}');
        RAISE NOTICE 'Created app database: ${APP_DB}';
    ELSE
        RAISE NOTICE 'App database already exists: ${APP_DB}';
    END IF;
END
\$\$;

-- Grant privileges on app database to app user
DO \$\$
BEGIN
    IF '${APP_DB}' != '' AND '${APP_DB}' != 'postgres' AND '${APP_USER}' != '' AND '${APP_USER}' != '${SUPERUSER}' THEN
        EXECUTE format('GRANT ALL PRIVILEGES ON DATABASE %I TO %I', '${APP_DB}', '${APP_USER}');
        RAISE NOTICE 'Granted privileges on ${APP_DB} to ${APP_USER}';
    END IF;
END
\$\$;

-- Verify replication user exists and has correct attributes
SELECT rolname, rolreplication, rolcanlogin FROM pg_roles WHERE rolname = '${REPL_USER}';

-- DEBUG: Show actual password hash to verify it's SCRAM format
SELECT rolname, left(rolpassword, 50) as hash_prefix FROM pg_authid WHERE rolname IN ('${SUPERUSER}', '${REPL_USER}');
EOSQL

echo "Post-bootstrap: users created (superuser: ${SUPERUSER}, replication: ${REPL_USER}, app: ${APP_USER}, database: ${APP_DB})"

# TEST: Actually verify the password works via TCP connection
echo "DEBUG: Testing replicator password via TCP connection..."
echo "DEBUG: Full REPL_PASS from YAML: [${REPL_PASS}]"
if PGPASSWORD="${REPL_PASS}" psql -h 127.0.0.1 -p 5432 -U "${REPL_USER}" -d postgres -c "SELECT 'AUTH_SUCCESS' as result;" 2>&1; then
    echo "DEBUG: *** PASSWORD TEST PASSED ***"
else
    echo "DEBUG: *** PASSWORD TEST FAILED ***"
fi

# Check what Patroni put in pgpass - this is what pg_basebackup actually uses!
echo "DEBUG: Contents of /tmp/pgpass (what Patroni uses):"
cat /tmp/pgpass 2>&1 || echo "pgpass not found"

# Generate SSL certificates
echo "Post-bootstrap: generating SSL certificates..."
bash /docker-entrypoint-initdb.d/init-ssl.sh

# Mark bootstrap as complete
touch "${RAILWAY_VOLUME_MOUNT_PATH:-/var/lib/postgresql/data}/.patroni_bootstrap_complete"

echo "Post-bootstrap: completed successfully"
